import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { CreateAuthDto, MailDto, passwordDto } from './dto/create-auth.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, In, Repository } from 'typeorm';
import { Token } from 'src/helper/utils/token';
import { hash } from 'src/helper/utils/hash';
import { AuthEntity } from 'src/model/auth.entity';
// import { authEntity } from 'src/model/auth.entity';
import {
  JwtPayload,
  roleType,
  VerifyPayload,
  permissionType,
  staffRoleType,
} from 'src/helper/types/index.type';
import { sendMail } from 'src/config/mail.config';
import { CreateUniversityDto } from '../university/dto/create-university.dto';
import { universityEntity } from 'src/model/university.entity';
import { CreateStudentDto } from '../student/dto/create-student.dto';
import { studentEntity } from 'src/model/student.entity';
import { staffEntity } from 'src/model/staff.entity';
import { createInstitutionDto } from '../institution/dto/create-institution.dto';
import { StaffPermissionEntity } from 'src/model/staffPermission.entity';
import { InstitutionEntity } from 'src/model/institution.entity';
import { MentorInResidenceEntity } from 'src/model/MentorInResidence.entity';
import { student_ambassadorEntity } from 'src/model/student_Ambassadors.entity';
import { UpdatePasswordDto } from '../mentor/dto/update-mentor.dto';

import { UserRoleAssignmentEntity } from 'src/model/user_role_assignment.entity';
// Define a type for the scope object for clarity
type PermissionScope = {
  universityId?: string;
  departmentId?: string;
  institutionId?: string;
};


@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(AuthEntity)
    private readonly authRepository: Repository<AuthEntity>,
    @InjectRepository(UserRoleAssignmentEntity)
    private readonly assignmentRepository: Repository<UserRoleAssignmentEntity>,


    @InjectRepository(staffEntity)
    private readonly staffRepository: Repository<staffEntity>,

    @InjectRepository(StaffPermissionEntity)
    private readonly staffPermissionRepository: Repository<StaffPermissionEntity>,

    @InjectRepository(universityEntity)
    private readonly universityRepository: Repository<universityEntity>,

    @InjectRepository(studentEntity)
    private readonly studentRepository: Repository<studentEntity>,

    @InjectRepository(student_ambassadorEntity)
    private readonly studentAmbassadorRepository: Repository<student_ambassadorEntity>,

    @InjectRepository(MentorInResidenceEntity)
    private readonly mentorRepository: Repository<MentorInResidenceEntity>,

    @InjectRepository(InstitutionEntity)
    private readonly institutionRepository: Repository<InstitutionEntity>,

    private token: Token,
    private hash: hash,
    private dataSource: DataSource,
  ) {}
  private roleUser = {
    university: 'university',
    superAdmin: 'superAdmin',
    student: 'student',
    institution: 'institution',
    staff: 'staff',
    student_ambassador: 'student_ambassador',
    mentor: 'mentor',
  };
  // async Login(createAuthDto: CreateAuthDto) {
  //   const { email, password } = createAuthDto;
  //   const authUser = await this.authRepository.findOne({
  //     where: { email },
  //     relations: [
  //       'university',
  //       'superAdmin',
  //       'student',
  //       'staff',
  //       'staff.university',
  //       'student_ambassador',
  //       'company',
  //       'mentor_in_residence',
  //     ],
  //   });
  //   if (!authUser) {
  //     throw new ForbiddenException(
  //       'The provided email does not match any registered user.',
  //     );
  //   } else {
  //     const status = await this.hash.verifyHashing(authUser.password, password);
  //     if (!status) {
  //       throw new UnauthorizedException(
  //         'The password entered is incorrect. Please try again.',
  //       );
  //     }
  //     const tokens = {
  //       accessToken: await this.token.generateAcessToken({
  //         sub: authUser.id,
  //         role: authUser.role,
  //       }),
  //       refreshToken: await this.token.generateRefreshToken({
  //         sub: authUser.id,
  //         role: authUser.role,
  //       }),
  //       role: authUser.role,
  //     };
  //     authUser.rToken = await this.hash.value(tokens.refreshToken);
  //     await this.authRepository.save(authUser);
  //     return tokens;
  //   }
  // }
  /**
   * This is the new core of the authorization system.
   * It checks if a user has a specific permission within a given scope.
   */
  async userHasPermission(
    userId: string,
    requiredPermission: string,
    scope: PermissionScope,
  ): Promise<boolean> {
    const user = await this.authRepository.findOne({
      where: { id: userId },
      relations: [
        'directPermissions',
        'roleAssignments',
        'roleAssignments.role',
        'roleAssignments.role.permissions',
        'roleAssignments.universityScope',
        'roleAssignments.departmentScope',
        'roleAssignments.institutionScope',
      ],
    });

    if (!user) {
      return false;
    }

    // 1. Check for Direct Permissions (Highest Priority)
    if (user.directPermissions.some((p) => p.name === requiredPermission)) {
      return true;
    }

    // 2. Check Role-Based Permissions within Scope
    for (const assignment of user.roleAssignments) {
      const hasPermissionInRole = assignment.role.permissions.some(
        (p) => p.name === requiredPermission,
      );

      if (!hasPermissionInRole) {
        continue; // This role doesn't have the permission, check the next one
      }

      // Now check if the assignment's scope matches the required scope
      
      // Case A: Global Scope (Super Admin)
      // If an assignment has no scope, it's global and grants permission everywhere.
      if (
        !assignment.universityScope &&
        !assignment.departmentScope &&
        !assignment.institutionScope
      ) {
        return true;
      }

      // Case B: University Scope
      if (
        scope.universityId &&
        assignment.universityScope?.id === scope.universityId
      ) {
        return true;
      }

      // Case C: Institution Scope
      if (
        scope.institutionId &&
        assignment.institutionScope?.id === scope.institutionId
      ) {
        return true;
      }
      
      // Case D: Department Scope (Handles hierarchy implicitly later)
      // Note: For a true hierarchy check (e.g., Division access grants Department access),
      // you would need to fetch the department's ancestors here.
      if (
        scope.departmentId &&
        assignment.departmentScope?.id === scope.departmentId
      ) {
        return true;
      }
    }

    return false; // If no checks pass, deny.
  }


  // async getMyPermissions(user: JwtPayload): Promise<{ role: string; permissions: permissionType[] }> {
  //   const dbuser = await this.authRepository.findOne({
  //     where: { id: user.sub },
  //   });
    
  //   if (dbuser?.role === roleType.UNIVERSITY) {
  //     // University gets all permissions for their content
  //     return {
  //       role: roleType.UNIVERSITY,
  //       permissions: [
  //         permissionType.RESEARCH_NEWS_CONTRIBUTOR,
  //         permissionType.RESEARCH_NEWS_REVIEWER,
  //         permissionType.RESEARCH_NEWS_EDITOR,
  //         permissionType.UNIVERSITY_PROFILE_ADMIN,
  //         permissionType.SCHOLARSHIP_CONTRIBUTOR,
  //         permissionType.SCHOLARSHIP_REVIEWER,
  //         permissionType.SCHOLARSHIP_EDITOR,
  //         permissionType.JOB_CONTRIBUTOR,
  //         permissionType.JOB_REVIEWER,
  //         permissionType.JOB_EDITOR,
  //         permissionType.OPPORTUNITY_CONTRIBUTOR,
  //         permissionType.OPPORTUNITY_REVIEWER,
  //         permissionType.OPPORTUNITY_EDITOR,
  //         permissionType.STUDENT_AMBASSADOR_ADMIN,
  //         permissionType.TEAM_MANAGEMENT_ADMIN,
  //       ],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.UNIVERSITY_STAFF) {
  //     const staff = await this.staffRepository.findOne({
  //       where: { auth: { id: dbuser.id } },
  //       relations: ['staffPermission'],
  //     });
  //     return {
  //       role: roleType.UNIVERSITY_STAFF,
  //       permissions: staff?.staffPermission
  //         .map((permission) => permission.name as permissionType)
  //         .filter((permission): permission is permissionType => 
  //           Object.values(permissionType).includes(permission)
  //         ) || [],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.DEPARTMENT_STAFF) {
  //     const staff = await this.staffRepository.findOne({
  //       where: { auth: { id: dbuser.id } },
  //       relations: ['staffPermission'],
  //     });
  //     return {
  //       role: roleType.DEPARTMENT_STAFF,
  //       permissions: staff?.staffPermission
  //         .map((permission) => permission.name as permissionType)
  //         .filter((permission): permission is permissionType => 
  //           Object.values(permissionType).includes(permission)
  //         ) || [],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.INSTITUTION) {
  //     // Institution gets all permissions for their content
  //     return {
  //       role: roleType.INSTITUTION,
  //       permissions: [
  //         permissionType.RESEARCH_NEWS_CONTRIBUTOR,
  //         permissionType.RESEARCH_NEWS_REVIEWER,
  //         permissionType.RESEARCH_NEWS_EDITOR,
  //         permissionType.COMPANY_PROFILE_ADMIN,
  //         permissionType.SCHOLARSHIP_CONTRIBUTOR,
  //         permissionType.SCHOLARSHIP_REVIEWER,
  //         permissionType.SCHOLARSHIP_EDITOR,
  //         permissionType.JOB_CONTRIBUTOR,
  //         permissionType.JOB_REVIEWER,
  //         permissionType.JOB_EDITOR,
  //         permissionType.OPPORTUNITY_CONTRIBUTOR,
  //         permissionType.OPPORTUNITY_REVIEWER,
  //         permissionType.OPPORTUNITY_EDITOR,
  //         permissionType.TEAM_MANAGEMENT_ADMIN,
  //       ],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.INSTITUTION_STAFF) {
  //     const staff = await this.staffRepository.findOne({
  //       where: { auth: { id: dbuser.id } },
  //       relations: ['staffPermission'],
  //     });
  //     return {
  //       role: roleType.INSTITUTION_STAFF,
  //       permissions: staff?.staffPermission
  //         .map((permission) => permission.name as permissionType)
  //         .filter((permission): permission is permissionType => 
  //           Object.values(permissionType).includes(permission)
  //         ) || [],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.DIVISION_STAFF) {
  //     const staff = await this.staffRepository.findOne({
  //       where: { auth: { id: dbuser.id } },
  //       relations: ['staffPermission'],
  //     });
  //     return {
  //       role: roleType.DIVISION_STAFF,
  //       permissions: staff?.staffPermission
  //         .map((permission) => permission.name as permissionType)
  //         .filter((permission): permission is permissionType => 
  //           Object.values(permissionType).includes(permission)
  //         ) || [],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.MENTOR) {
  //     return {
  //       role: roleType.MENTOR,
  //       permissions: [permissionType.MENTOR_ADMIN],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.STUDENT_AMBASSADOR) {
  //     return {
  //       role: roleType.STUDENT_AMBASSADOR,
  //       permissions: [permissionType.STUDENT_AMBASSADOR_ADMIN],
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.STUDENT) {
  //     return {
  //       role: roleType.STUDENT,
  //       permissions: [], // Students have no special permissions
  //     };
  //   }
    
  //   if (dbuser?.role === roleType.SUPER_ADMIN) {
  //     return {
  //       role: roleType.SUPER_ADMIN,
  //       permissions: Object.values(permissionType), // Super admin gets all permissions
  //     };
  //   }
    
  //   // Default case
  //   return {
  //     role: dbuser?.role || 'unknown',
  //     permissions: [],
  //   };
  // }

  // async getPermissionList(staffRole?: staffRoleType) {
  //   if (staffRole) {
  //     if (staffRole === staffRoleType.ALL_STAFF) {
  //       // Return permissions available to all staff types
  //       const permissionList = await this.staffPermissionRepository.find({
  //         where: { staffRole: staffRoleType.ALL_STAFF },
  //       });
  //       return permissionList;
  //     } else {
  //       // Return permissions for specific staff role and ALL_STAFF permissions
  //       const permissionList = await this.staffPermissionRepository.find({
  //         where: [
  //           { staffRole: staffRole },
  //           { staffRole: staffRoleType.ALL_STAFF }
  //         ],
  //       });
  //       return permissionList;
  //     }
  //   } else {
  //     // Return all permissions when no specific staff role is requested
  //     const permissionList = await this.staffPermissionRepository.find();
  //     return permissionList;
  //   }
  // }

  //   async GoogleOauth(auth: any) {
  //     const { email } = auth;
  //     const authUser = await this.authRepository.findOne({
  //       where: { email },
  //       relations: ['user']
  //     });
  //     const userId = authUser.user.id;
  //     const tokens = {
  //       accessToken: await this.token.generateAcessToken({
  //         sub: userId,
  //         role: authUser.role,
  //       }),
  //       refreshToken: await this.token.generateRefreshToken({
  //         sub: userId,
  //         role: authUser.role,
  //       }),
  //       role: authUser.role,
  //     };
  //     authUser.rToken = await this.hash.value(tokens.refreshToken);
  //     await this.authRepository.save(authUser);
  //     return tokens;
  //   }

  //   //verify email
  async getVerify(mail: MailDto, role: roleType) {
    try {
      const { email } = mail;
      const existingUser = await this.authRepository.findOne({
        where: { email },
      });

      if (existingUser) {
        throw new ForbiddenException(
          'An account with this email already exists.',
        );
      } else {
        const token = await this.token.generateVerifyToken({
          email: email,
          role: role,
        });
        const frontURL = `${process.env.FRONT_URL}/account/verify/${token}?role=${role}`;
        console.log(token);
        try {
          sendMail(email, 'Email Verification', this.emailTemplate(frontURL));
        } catch (error) {
          throw error;
        }
        return true;
      }
    } catch (e) {
      throw new BadRequestException(e.message);
    }
  }

  async updatePassword(userId: string, passwordDto: UpdatePasswordDto) {
    const user = await this.authRepository.findOne({ where: { id: userId } });
    if (!user) {
      throw new BadRequestException("User does'nt exist");
    }
    const { oldPassword, newPassword } = passwordDto;
    if (!(await this.hash.verifyHashing(user.password, oldPassword))) {
      throw new UnauthorizedException(
        'The password entered is incorrect. Please try again.',
      );
    }
    const hash = await this.hash.value(newPassword);
    user.password = hash;
    return await this.authRepository.save(user);
  }

  //   //register University
  // async createUniversity(
  //   signupDTO: CreateUniversityDto,
  //   jwtPayload: VerifyPayload,
  // ) {
  //   const queryRunner = this.dataSource.createQueryRunner();
  //   await queryRunner.connect();
  //   await queryRunner.startTransaction();
  //   try {
  //     if (jwtPayload.role !== roleType.UNIVERSITY) {
  //       throw new ForbiddenException(
  //         'Only universities can create universities',
  //       );
  //     }
  //     const email = jwtPayload.email;
  //     const { university_name, password, country } = signupDTO;
  //     const hashedPassword = await this.hash.value(password);
  //     const auth = new authEntity();
  //     auth.email = email;
  //     (auth.password = hashedPassword), (auth.role = roleType.UNIVERSITY);
  //     await queryRunner.manager.save(auth);
  //     const university = new universityEntity();
  //     university.university_name = university_name;
  //     university.country = country;
  //     university.auth = auth;
  //     await queryRunner.manager.save(university);
  //     await queryRunner.commitTransaction();
  //     return true;
  //   } catch (error) {
  //     console.log(error);
  //     await queryRunner.rollbackTransaction();
  //     throw new ForbiddenException(error.errorResponse);
  //   } finally {
  //     await queryRunner.release();
  //   }
  // }

  //register Student
  // async createStudent(signupDTO: CreateStudentDto, jwtPayload: VerifyPayload) {
  //   const queryRunner = this.dataSource.createQueryRunner();
  //   await queryRunner.connect();
  //   await queryRunner.startTransaction();
  //   try {
  //     const email = jwtPayload.email;
  //     const { name, password } = signupDTO;
  //     const hashedPassword = await this.hash.value(password);
  //     const auth = new authEntity();
  //     auth.email = email;
  //     auth.password = hashedPassword;
  //     auth.role = roleType.STUDENT;

  //     await queryRunner.manager.save(auth);

  //     const student = new studentEntity();
  //     student.name = name;
  //     // student.address = address;
  //     // student.phone = phone;
  //     // student.photo = photo;
  //     // student.date_of_birth = date_of_birth;
  //     student.auth = auth;
  //     await queryRunner.manager.save(student);
  //     await queryRunner.commitTransaction();
  //     return true;
  //   } catch (error) {
  //     console.log(error);
  //     await queryRunner.rollbackTransaction();
  //     throw new ForbiddenException(error.errorResponse);
  //   } finally {
  //     await queryRunner.release();
  //   }
  // }

  //register company
  // async createInstitution(
  //   signupDTO: createInstitutionDto,
  //   jwtPayload: VerifyPayload,
  // ) {
  //   const queryRunner = this.dataSource.createQueryRunner();
  //   await queryRunner.connect();
  //   await queryRunner.startTransaction();
  //   try {
  //     if (jwtPayload.role !== roleType.INSTITUTION) {
  //       throw new ForbiddenException(
  //         'Only institutions can create institutions',
  //       );
  //     }
  //     const email = jwtPayload.email;
  //     const { name, password, country } = signupDTO;
  //     const hashedPassword = await this.hash.value(password);
  //     const auth = new authEntity();
  //     auth.email = email;
  //     (auth.password = hashedPassword), (auth.role = roleType.INSTITUTION);
  //     await queryRunner.manager.save(auth);
  //     const company = new InstitutionEntity();
  //     company.name = name;
  //     company.country = country;
  //     company.auth = auth;
  //     await queryRunner.manager.save(company);
  //     await queryRunner.commitTransaction();
  //     return true;
  //   } catch (error) {
  //     console.log(error);
  //     await queryRunner.rollbackTransaction();
  //     throw new ForbiddenException(error.errorResponse);
  //   } finally {
  //     await queryRunner.release();
  //   }
  // }

  // async forgetPasswordAdmin(body: MailDto): Promise<boolean> {
  //   const existingUser = await this.authRepository.findOne({
  //     where: { email: body.email },
  //     relations: ['student', 'superAdmin', 'university', 'company'],
  //   });
  //   if (!existingUser) {
  //     throw new NotFoundException('No account found with this email address.');
  //   }
  //   const token = await this.token.generateUtilToken({
  //     sub: existingUser.id,
  //     role: existingUser.role,
  //   });
  //   const frontURL = `${process.env.FRONT_URL}/reset?${token}`;
  //   try {
  //     sendMail(body.email, 'Password Reset', this.passwordTemplate(frontURL));
  //   } catch (error) {
  //     throw error;
  //   }
  //   return true;
  // }

  // async getCombinedUserInfo(user: JwtPayload) {
  //   const { role, sub } = user;
  //   let resp;
  //   if (role === roleType.UNIVERSITY) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['university'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.university.university_name,
  //       photo: authData?.university.logo,
  //     };
  //   } else if (role === roleType.STUDENT_AMBASSADOR) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['student_ambassador'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.student_ambassador.name,
  //       photo: authData?.student_ambassador.photo,
  //     };
  //   } else if (role === roleType.MENTOR) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['mentor_in_residence'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.mentor_in_residence.name,
  //       photo: authData?.mentor_in_residence.photo,
  //     };
  //   } else if (role === roleType.DEPARTMENT_STAFF) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['staff', 'staff.department', 'staff.staffPermission'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.staff.name,
  //       photo: authData?.staff.photo,
  //       department: authData?.staff.department.dept_name,
  //       permission: authData?.staff.staffPermission.map(
  //         (permission) => permission.name,
  //       ),
  //     };
  //   } else if (role === roleType.STUDENT) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['student'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.student.name,
  //       photo: authData?.student.photo,
  //     };
  //   } else if (role === roleType.INSTITUTION) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['company'],
  //     });
  //     console.log(authData);
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.company?.name,
  //       photo: authData?.company?.logo,
  //     };
  //   }
  //   if (role === roleType.UNIVERSITY_STAFF) {
  //     const authData = await this.authRepository.findOne({
  //       where: { id: sub },
  //       relations: ['staff', 'staff.staffPermission'],
  //     });
  //     resp = {
  //       role: authData?.role,
  //       name: authData?.staff.name,
  //       photo: authData?.staff.photo,
  //       permission: authData?.staff.staffPermission.map(
  //         (permission) => permission.name,
  //       ),
  //     };
  //   }
  //   {
  //     return resp;
  //   }
  // }
  async getCombinedUserInfo(user: JwtPayload) {
    const authData = await this.authRepository.findOne({
      where: { id: user.sub },
      relations: [
        'university', // For university owner profile
        'staff',      // For staff profile
        'student',    // For student profile
        'student_ambassador',
        'mentor_in_residence',
        'department',
        'institute',
      ],
    });

    if (!authData) throw new NotFoundException('User not found');

    if (authData.university) {
      return { type: 'University', name: authData.university.university_name, photo: authData.university.logo };
    }
    if (authData.staff) {
      return { type: 'Staff', name: authData.staff.name, photo: authData.staff.photo, title: authData.staff.job_title };
    }
    if (authData.student) {
        return { type: 'Student', name: authData.student.name, photo: authData.student.photo };
    }
    // ... handle other profile types

    return { type: 'Unknown', name: 'N/A', photo: null };
  }

  async refreshTokenAdmin(user: JwtPayload) {
    return await this.token.generateAcessToken({
      sub: user.sub,
      role: user.role,
    });
  }

  async resetPassword(id: string, passwordDto: passwordDto) {
    try {
      const { password } = passwordDto;
      const hash = await this.hash.value(password);
      const user = await this.authRepository.findOne({ where: { id } });
      if (!user) {
        throw new BadRequestException("User does'nt exist");
      }
      user.password = hash;
      return await this.authRepository.save(user);
    } catch (e) {}
  }

  async updateProfilePhoto(id: string, role: roleType, path: string) {
    switch (role) {
      case roleType.UNIVERSITY: {
        const findUniversity = await this.authRepository.findOne({
          where: { id },
          relations: ['university'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findUniversity) {
          this.universityRepository.update(findUniversity.university.id, {
            logo: photo,
          });
          return await this.authRepository.save(findUniversity);
        }
      }
      case roleType.STUDENT: {
        const findStudent = await this.authRepository.findOne({
          where: { id },
          relations: ['student'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findStudent) {
          this.studentRepository.update(findStudent.student.id, { photo });
          return await this.authRepository.save(findStudent);
        }
      }
      case roleType.INSTITUTION: {
        const findInstitution = await this.authRepository.findOne({
          where: { id },
          relations: ['institution'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findInstitution) {
          // this.institutionRepository.update(findInstitution.institution.id, { photo });
          // return await this.authRepository.save(findInstitution);
        }
      }
      case roleType.UNIVERSITY_STAFF: {
        const findStaff = await this.authRepository.findOne({
          where: { id },
          relations: ['staff', 'staff.staffPermission'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findStaff) {
          await this.staffRepository.update(findStaff.id, { photo });
        }
      }
      case roleType.DEPARTMENT_STAFF: {
        const findStaff = await this.authRepository.findOne({
          where: { id },
          relations: ['staff', 'staff.staffPermission'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findStaff) {
          await this.staffRepository.update(findStaff.id, { photo });
        }
      }
      case roleType.STUDENT_AMBASSADOR: {
        const findStudentAmbassador = await this.authRepository.findOne({
          where: { id },
          relations: ['student_ambassador'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findStudentAmbassador) {
          this.studentAmbassadorRepository.update(
            findStudentAmbassador.student_ambassador.id,
            { photo },
          );
          return await this.authRepository.save(findStudentAmbassador);
        }
      }
      case roleType.MENTOR: {
        const findMentor = await this.authRepository.findOne({
          where: { id },
          relations: ['mentor_in_residence'],
        });
        const photo = `${process.env.BASE_URL}/${path}`;
        if (findMentor) {
          this.mentorRepository.update(findMentor.mentor_in_residence.id, {
            photo,
          });
          return await this.authRepository.save(findMentor);
        }
      }
    }
  }

  passwordTemplate(resetUrl: any) {
    return `
      <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Reset Your Password</title>
      <style>
          body {
              font-family: Arial, sans-serif;
              background-color: #f4f4f4;
              margin: 0;
              padding: 20px;
          }
          .container {
              max-width: 500px;
              margin: 0 auto;
              background-color: #fff;
              padding: 30px;
              border-radius: 10px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
              text-align: center;
          }
          h1 {
              color: #333;
              margin-bottom: 20px;
          }
          p {
              font-size: 16px;
              color: #555;
              margin-bottom: 30px;
          }
          .button {
              display: inline-block;
              width: 80%;
              padding: 12px;
              background-color: #007BFF;
              color: white;
              text-align: center;
              border-radius: 5px;
              font-size: 16px;
              text-decoration: none;
              cursor: pointer;
              transition: background-color 0.3s;
          }
          .button:hover {
              background-color: #0056b3;
          }
          .footer {
              margin-top: 20px;
              font-size: 14px;
              color: #777;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h1>Password Reset Request</h1>
          <p>Hello, User</p>
          <p>You've requested to reset your password for your Research Shock account. Click the link below to set a new password:</p>
          <a href="${resetUrl}" class="button" style="color: white; text-decoration: none;">Reset My Password</a>
          <p>If you didn't request this, please ignore this email.</p>
          <p class="footer">© 2025 Research Shock. All rights reserved.</p>
      </div>
  </body>
  </html>
    `;
  }

  emailTemplate(verifyUrl: any) {
    return `
      <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Verify Your Email</title>
      <style>
          body {
              font-family: Arial, sans-serif;
              background-color: #f4f4f4;
              margin: 0;
              padding: 20px;
          }
          .container {
              max-width: 500px;
              margin: 0 auto;
              background-color: #fff;
              padding: 30px;
              border-radius: 10px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
              text-align: center;
          }
          h1 {
              color: #333;
              margin-bottom: 20px;
          }
          p {
              font-size: 16px;
              color: #555;
              margin-bottom: 30px;
          }
          .button {
              display: inline-block;
              width: 80%;
              padding: 12px;
              background-color: #007BFF;
              color: white;
              text-align: center;
              border-radius: 5px;
              font-size: 16px;
              text-decoration: none;
              cursor: pointer;
              transition: background-color 0.3s;
          }
          .button:hover {
              background-color: #0056b3;
          }
          .footer {
              margin-top: 20px;
              font-size: 14px;
              color: #777;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h1>Verify your email</h1>
          <p>Hello, User</p>
          <p>You've requested to verify your email for your Research Shock account. Click the link below to verify the email:</p>
          <a href="${verifyUrl}" class="button" style="color: white; text-decoration: none;">Verify my email </a>
          <p>If you didn't request this, please ignore this email.</p>
          <p class="footer">© 2025 Research Shock. All rights reserved.</p>
      </div>
  </body>
  </html>
    `;
  }
}
