import {
  BadRequestException,
  ConflictException,
  ForbiddenException,
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { CreateAuthDto, MailDto, passwordDto } from './dto/create-auth.dto';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, In, Repository } from 'typeorm';
import { Token } from 'src/helper/utils/token';
import { hash } from 'src/helper/utils/hash';
import {
  JwtPayload,
  VerifyPayload,
} from 'src/helper/types/index.type';
import { sendMail } from 'src/config/mail.config';
import { CreateUniversityDto } from '../university/dto/create-university.dto';
import { CreateStudentDto } from '../student/dto/create-student.dto';
import { createInstitutionDto } from '../institution/dto/create-institution.dto';
import { UpdatePasswordDto } from '../mentor/dto/update-mentor.dto';

import { AuthEntity } from 'src/model/auth.entity';
import { UniversityEntity } from 'src/model/university.entity';
import { StudentEntity } from 'src/model/student.entity';
import { StaffEntity } from 'src/model/staff.entity';
import { InstitutionEntity } from 'src/model/institution.entity';
import { MentorInResidenceEntity } from 'src/model/mentor_in_residence.entity';
import { StudentAmbassadorEntity } from 'src/model/student_ambassador.entity';

import { PermissionEntity } from 'src/model/permission.entity';
import { RoleEntity } from 'src/model/role.entity';
import { UserRoleAssignmentEntity } from 'src/model/user_role_assignment.entity';

// Define a type for the scope object for clarity
type PermissionScope = {
  universityId?: string;
  departmentId?: string;
  institutionId?: string;
};


@Injectable()
export class AuthService {
  constructor(

    @InjectRepository(AuthEntity)
    private readonly authRepository: Repository<AuthEntity>,

    @InjectRepository(UserRoleAssignmentEntity)
    private readonly assignmentRepository: Repository<UserRoleAssignmentEntity>,

    
    @InjectRepository(PermissionEntity)
    private readonly permissionRepository: Repository<PermissionEntity>,
    
    @InjectRepository(RoleEntity)
    private readonly roleRepository: Repository<RoleEntity>,
    
    @InjectRepository(UniversityEntity)
    private readonly universityRepository: Repository<UniversityEntity>,
    
    @InjectRepository(StudentEntity)
    private readonly studentRepository: Repository<StudentEntity>,
    
    @InjectRepository(StaffEntity)
    private readonly staffRepository: Repository<StaffEntity>,

    @InjectRepository(StudentAmbassadorEntity)
    private readonly studentAmbassadorRepository: Repository<StudentAmbassadorEntity>,

    @InjectRepository(MentorInResidenceEntity)
    private readonly mentorInResidenceRepository: Repository<MentorInResidenceEntity>,

    @InjectRepository(InstitutionEntity)
    private readonly institutionRepository: Repository<InstitutionEntity>,

    private token: Token,
    private hash: hash,
    private readonly dataSource: DataSource,
  ) {}
  private roleUser = {
    university: 'university',
    superAdmin: 'superAdmin',
    student: 'student',
    institution: 'institution',
    staff: 'staff',
    student_ambassador: 'student_ambassador',
    mentor: 'mentor',
  };

  async login(createAuthDto: CreateAuthDto) {
    const { email, password } = createAuthDto;
    const authUser = await this.authRepository.findOne({
      where: { email },
      select: ['id', 'password'], // Only select necessary fields
    });

    if (!authUser) {
      throw new ForbiddenException('The provided email does not match any registered user.');
    }

    const passwordMatches = await this.hash.verifyHashing(authUser.password, password);
    if (!passwordMatches) {
      throw new UnauthorizedException('The password entered is incorrect.');
    }

    const tokens = {
      accessToken: await this.token.generateAcessToken({ sub: authUser.id }),
      refreshToken: await this.token.generateRefreshToken({ sub: authUser.id }),
    };

    const hashedRToken = await this.hash.value(tokens.refreshToken);
    await this.authRepository.update(authUser.id, { rToken: hashedRToken });

    return tokens;
  }
  /**
   * This is the new core of the authorization system.
   * It checks if a user has a specific permission within a given scope.
   */
  async userHasPermission(
    userId: string,
    requiredPermission: string,
    scope: PermissionScope,
  ): Promise<boolean> {
    const user = await this.authRepository.findOne({
      where: { id: userId },
      relations: {
        directPermissions: true,
        roleAssignments: {
          role: {
            permissions: true,
          },
          universityScope: true,
          departmentScope: true,
          institutionScope: true,
        },
      },
    });

    if (!user) {
      return false;
    }

    // 1. Check for Direct Permissions (Highest Priority)
    if (user.directPermissions.some((p) => p.name === requiredPermission)) {
      return true;
    }

    // 2. Check Role-Based Permissions within Scope
    for (const assignment of user.roleAssignments) {
      const hasPermissionInRole = assignment.role.permissions.some(
        (p) => p.name === requiredPermission,
      );

      if (!hasPermissionInRole) {
        continue; // This role doesn't have the permission, check the next one
      }

      // Now check if the assignment's scope matches the required scope
      
      // Case A: Global Scope (Super Admin)
      // If an assignment has no scope, it's global and grants permission everywhere.
      if (
        !assignment.universityScope &&
        !assignment.departmentScope &&
        !assignment.institutionScope
      ) {
        return true;
      }

      // Case B: University Scope
      if (
        scope.universityId &&
        assignment.universityScope?.id === scope.universityId
      ) {
        return true;
      }

      // Case C: Institution Scope
      if (
        scope.institutionId &&
        assignment.institutionScope?.id === scope.institutionId
      ) {
        return true;
      }
      
      // Case D: Department Scope (Handles hierarchy implicitly later)
      // Note: For a true hierarchy check (e.g., Division access grants Department access),
      // you would need to fetch the department's ancestors here.
      if (
        scope.departmentId &&
        assignment.departmentScope?.id === scope.departmentId
      ) {
        return true;
      }
    }

    return false; // If no checks pass, deny.
  }

  async refreshToken(user: JwtPayload) {
    return await this.token.generateAcessToken({
      sub: user.sub,
    });
  }

  async resetPassword(id: string, passwordDto: passwordDto) {
    try {
      const { password } = passwordDto;
      const hash = await this.hash.value(password);
      const user = await this.authRepository.findOne({ where: { id } });
      if (!user) {
        throw new BadRequestException("User does'nt exist");
      }
      user.password = hash;
      return await this.authRepository.save(user);
    } catch (e) {}
  }

  async getCombinedUserInfo(user: JwtPayload) {
    const authData = await this.authRepository.findOne({
      where: { id: user.sub },
      relations: [
        'university', // For university owner profile
        'staff',      // For staff profile
        'student',    // For student profile
        'student_ambassador',
        'mentor_in_residence',
        'department',
        'institute',
      ],
    });

    if (!authData) throw new NotFoundException('User not found');

    if (authData.university) {
      return { type: 'University', name: authData.university.university_name, photo: authData.university.logo };
    }
    if (authData.staff) {
      return { type: 'Staff', name: authData.staff.name, photo: authData.staff.photo, title: authData.staff.job_title };
    }
    if (authData.student) {
        return { type: 'Student', name: authData.student.name, photo: authData.student.photo };
    }
    // ... handle other profile types

    return { type: 'Unknown', name: 'N/A', photo: null };
  }



  // Other methods like refreshToken, register, etc., remain largely the same logically,
  // but should be cleaned up to remove the old `role` column logic.
  // For example, in createUniversity:
  // auth.role = roleType.UNIVERSITY; // THIS LINE IS DELETED
  // Instead, after saving the university, you would create a UserRoleAssignmentEntity


  // async createUniversity(signupDTO: CreateUniversityDto, jwtPayload: VerifyPayload) {
  //   const queryRunner = this.dataSource.createQueryRunner();
  //   await queryRunner.connect();
  //   await queryRunner.startTransaction();
  //   try {
  //     const email = jwtPayload.email;
  //     const existingUser = await this.authRepository.findOneBy({ email });
  //     if (existingUser) throw new ConflictException('Email already exists.');

  //     const { university_name, password, country } = signupDTO;
  //     const hashedPassword = await this.hash.value(password);

  //     const auth = queryRunner.manager.create(AuthEntity, { email, password: hashedPassword });
  //     await queryRunner.manager.save(auth);

  //     const university = queryRunner.manager.create(UniversityEntity, {
  //       university_name,
  //       country,
  //       auth,
  //     });
  //     await queryRunner.manager.save(university);

  //     const universityAdminRole = await this.roleRepository.findOneBy({ name: 'UNIVERSITY_ADMIN' });
  //     if (universityAdminRole) {
  //       const assignment = queryRunner.manager.create(UserRoleAssignmentEntity, {
  //         user: auth,
  //         role: universityAdminRole,
  //         universityScope: university,
  //       });
  //       await queryRunner.manager.save(assignment);
  //     }

  //     await queryRunner.commitTransaction();
  //     return { message: 'University created successfully.' };
  //   } catch (error) {
  //     await queryRunner.rollbackTransaction();
  //     throw new BadRequestException(error.message || 'Could not create university.');
  //   } finally {
  //     await queryRunner.release();
  //   }
  // }

  // async createStudent(signupDTO: CreateStudentDto, jwtPayload: VerifyPayload) {
  //   const queryRunner = this.dataSource.createQueryRunner();
  //   await queryRunner.connect();
  //   await queryRunner.startTransaction();
  //   try {
  //     const email = jwtPayload.email;
  //     const existingUser = await this.authRepository.findOneBy({ email });
  //     if (existingUser) throw new ConflictException('Email already exists.');

  //     const { name, password } = signupDTO;
  //     const hashedPassword = await this.hash.value(password);
      
  //     const auth = queryRunner.manager.create(AuthEntity, { email, password: hashedPassword });
  //     await queryRunner.manager.save(auth);

  //     const student = queryRunner.manager.create(StudentEntity, { name, auth });
  //     await queryRunner.manager.save(student);

  //     await queryRunner.commitTransaction();
  //     return { message: 'Student created successfully.' };
  //   } catch (error) {
  //     await queryRunner.rollbackTransaction();
  //     throw new BadRequestException(error.message || 'Could not create student.');
  //   } finally {
  //     await queryRunner.release();
  //   }
  // }

  // async updateProfilePhoto(id: string, role: roleType, path: string) {
  //   switch (role) {
  //     case roleType.UNIVERSITY: {
  //       const findUniversity = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['university'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findUniversity) {
  //         this.universityRepository.update(findUniversity.university.id, {
  //           logo: photo,
  //         });
  //         return await this.authRepository.save(findUniversity);
  //       }
  //     }
  //     case roleType.STUDENT: {
  //       const findStudent = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['student'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findStudent) {
  //         this.studentRepository.update(findStudent.student.id, { photo });
  //         return await this.authRepository.save(findStudent);
  //       }
  //     }
  //     case roleType.INSTITUTION: {
  //       const findInstitution = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['institution'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findInstitution) {
  //         // this.institutionRepository.update(findInstitution.institution.id, { photo });
  //         // return await this.authRepository.save(findInstitution);
  //       }
  //     }
  //     case roleType.UNIVERSITY_STAFF: {
  //       const findStaff = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['staff', 'staff.staffPermission'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findStaff) {
  //         await this.staffRepository.update(findStaff.id, { photo });
  //       }
  //     }
  //     case roleType.DEPARTMENT_STAFF: {
  //       const findStaff = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['staff', 'staff.staffPermission'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findStaff) {
  //         await this.staffRepository.update(findStaff.id, { photo });
  //       }
  //     }
  //     case roleType.STUDENT_AMBASSADOR: {
  //       const findStudentAmbassador = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['student_ambassador'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findStudentAmbassador) {
  //         this.studentAmbassadorRepository.update(
  //           findStudentAmbassador.student_ambassador.id,
  //           { photo },
  //         );
  //         return await this.authRepository.save(findStudentAmbassador);
  //       }
  //     }
  //     case roleType.MENTOR: {
  //       const findMentor = await this.authRepository.findOne({
  //         where: { id },
  //         relations: ['mentor_in_residence'],
  //       });
  //       const photo = `${process.env.BASE_URL}/${path}`;
  //       if (findMentor) {
  //         this.mentorRepository.update(findMentor.mentor_in_residence.id, {
  //           photo,
  //         });
  //         return await this.authRepository.save(findMentor);
  //       }
  //     }
  //   }
  // }

  passwordTemplate(resetUrl: any) {
    return `
      <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Reset Your Password</title>
      <style>
          body {
              font-family: Arial, sans-serif;
              background-color: #f4f4f4;
              margin: 0;
              padding: 20px;
          }
          .container {
              max-width: 500px;
              margin: 0 auto;
              background-color: #fff;
              padding: 30px;
              border-radius: 10px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
              text-align: center;
          }
          h1 {
              color: #333;
              margin-bottom: 20px;
          }
          p {
              font-size: 16px;
              color: #555;
              margin-bottom: 30px;
          }
          .button {
              display: inline-block;
              width: 80%;
              padding: 12px;
              background-color: #007BFF;
              color: white;
              text-align: center;
              border-radius: 5px;
              font-size: 16px;
              text-decoration: none;
              cursor: pointer;
              transition: background-color 0.3s;
          }
          .button:hover {
              background-color: #0056b3;
          }
          .footer {
              margin-top: 20px;
              font-size: 14px;
              color: #777;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h1>Password Reset Request</h1>
          <p>Hello, User</p>
          <p>You've requested to reset your password for your Research Shock account. Click the link below to set a new password:</p>
          <a href="${resetUrl}" class="button" style="color: white; text-decoration: none;">Reset My Password</a>
          <p>If you didn't request this, please ignore this email.</p>
          <p class="footer">© 2025 Research Shock. All rights reserved.</p>
      </div>
  </body>
  </html>
    `;
  }

  emailTemplate(verifyUrl: any) {
    return `
      <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Verify Your Email</title>
      <style>
          body {
              font-family: Arial, sans-serif;
              background-color: #f4f4f4;
              margin: 0;
              padding: 20px;
          }
          .container {
              max-width: 500px;
              margin: 0 auto;
              background-color: #fff;
              padding: 30px;
              border-radius: 10px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
              text-align: center;
          }
          h1 {
              color: #333;
              margin-bottom: 20px;
          }
          p {
              font-size: 16px;
              color: #555;
              margin-bottom: 30px;
          }
          .button {
              display: inline-block;
              width: 80%;
              padding: 12px;
              background-color: #007BFF;
              color: white;
              text-align: center;
              border-radius: 5px;
              font-size: 16px;
              text-decoration: none;
              cursor: pointer;
              transition: background-color 0.3s;
          }
          .button:hover {
              background-color: #0056b3;
          }
          .footer {
              margin-top: 20px;
              font-size: 14px;
              color: #777;
          }
      </style>
  </head>
  <body>
      <div class="container">
          <h1>Verify your email</h1>
          <p>Hello, User</p>
          <p>You've requested to verify your email for your Research Shock account. Click the link below to verify the email:</p>
          <a href="${verifyUrl}" class="button" style="color: white; text-decoration: none;">Verify my email </a>
          <p>If you didn't request this, please ignore this email.</p>
          <p class="footer">© 2025 Research Shock. All rights reserved.</p>
      </div>
  </body>
  </html>
    `;
  }
}
